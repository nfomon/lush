Screw it, I'm making my own stack-VM!

Everything is conceptually on a stack.  That makes executing the bytecode easy.
And it's easy to express our operations in our custom bytecode as well.

Note:
This is not the "ideal" vm for this language.  Ideally we would use the ELF
stack the way we want, and manipulate the program counter, stack/frame
pointers, etc. the way we want.  But that's not what we're doing here.  The VM
program is written in C, this program that reads text input and determines
"instructions" to run, it will put them on its own false stack.  Because it
saves us tons of work, to be a bad emulator :)  For now.

*cough*

I'm reading in the bytecode, as written by the AST.  The bytecode is a stream
of "instructions".  I read an instruction until it is done, and then execute
it.

Some instructions just describe how to put a value on the stack, that is, at
the location of the stack pointer (and increment the stack pointer).

Some instructions describe an operation to be performed: 

ObjectLiteral:

object t m              # t = # types, m = # members
type name a             # these may have been autogenerated
type name b             # specifically by the member def
type autoname & a b
member name type value

NewInit:
new name type value

Assign:
assign name value

Variable -- nope, just the name of an existing symbol
   -- what to do about a.b.c ?
var a 3
dot b
dot c  ????
Identifier -- nope, just a new name

ProcCall:
proc name func n        # n = # args, name = a name for this proc invocation? so we can assign it to a value later??
arg name value
arg name value

To do a proc call then assign to a value, do the proc first giving the result a
name, then refer to that name in the assign value??

-----
PC: &foo
stack[
  x int 7
  foo @() {
    new q int 0
    assign &q 12
    if &q 12 {
      call foo          #-- pc20
    }
    return
  }
  y object object
  call foo pc0          #-- pc40
  q int 12
  call foo pc20         #-- pc50
  q int 13       # (pretend)
  return                    # return means unwind the stack up to the nearest
                            # 'call'.  kill that too, but set the pc to its
                            # stated pc, we just finished that.
SP]

new x int 4       # PC is 0, so exec the new.  just puts x:int=4 on the stack.
assign &x 7       # PC is 0, so exec the assign.  replace x's value with 7.

function foo # no args, no return   # PS is 0, so exec the function, meaning put foo:@(){...} on the stack.
  new q int 0     # this instruction is put on the stack as part of foo's body.
  assign q 12     # this instruction is put on the stack as part of foo's body.
  if q == 12      # this instruction is put on the stack as part of foo's body.
    call foo      # this instruction is put on the stack as part of foo's body.
  return          # this instruction is put on the stack as part of foo's body.
done              # done exec'ing the function

new y             # PC is 0, so exec the new.  just puts y:object=object on the stack.
call foo          # PC is 0, so exec the call.  puts 'call foo' on the stack, moves PC to &foo, sets return to 0.


It seems that I cannot change the number of statements in a function after it has been defined.
So how do lists work?  how can I append anything into anything?

sigh.  guess values need to be dynamically-allocated.
it would be nice to know more about the performance characteristics of malloc.

two apparent choices:
1. I have a stack, it points to dynamically-allocated object *values*
2. I keep values also on the stack, but have to do mad tricks / lots of copying
during function unwinding! and um, it's a loooot like garbage collection..

let's go with 1.  this is in the realm of implementation-detail anyway :)

-----

Object bodies and function bodies are themselves values.  And values are
dynamically-allocated.  That's pretty sane actually.  But we need some practice.

symbol table:
assigns name to vector of object*'s

what is an object? a name and a vector of members :)

{f(a)}
call f - 1      call function, no return value, one arg
arg a

{
  new x
  x = 4
}

new x object      # we don't care about types! just the object.  but how do I get the *right* object??  oh, the bytecode will say what depth to grab it from :)
 - find the appropriate object in symbol table
 - add a new x to the end of the symboltable[x] vector
 - duplicate the object, assign the new instance pointer to x
assign x 4
 - call its constructor method (TODO)

-----

new object - 1        # new symbol object, no source (it's the root), 1 member
member name - 0       # a silly bare member, for now, it also has no source.
                      # we WILL give it a value, it just will not be object ;)
new @ object 0        # new symbol @, source is object, 0 members for now

new A object 3
  member x object 0
  member y @ 1
    method <args> <# statements>
      <statement...>

this is annoying.... we're hitting the same problem from eval.. everything needs to be nested and now we really need a smart parser? aaaaaah

Not quite!  We are reading statements that we do want to execute immediately.
Some of them are arbitrarily long, but they're capable of telling us exactly
how long they are.  We need an elegant way to read until we're done, and then
do something.

We might want to use boost::spirit for this, sure.  But we don't need to, either.

spirit:
Bytecode = Statement+
Statement = New
New = 'new' <name> <source> Member* 'endnew'
Member = 'member' <name> <source> Member* 'endmember'

-----

boost::qi gives us a nice way to write our grammar, and pass each individual
item to a function that receives it.  Cool.

Now we want to build structures based on sequences of things.  Most are bare
data to a few control things that we can maybe put on an explicit
interpretation-stack, ok.

-----

with our forward-iterator parsing, am I correct that our phrase_parse() will not finish until end of input ??

-----

A parser has an attribute, which is its return-thing.  Let's decide what we
want to be putting together throughout our parsing.

Rule: simple thing, coagulates attributes somehow
Grammar: can do all kinds of stuff to produce its attribute

ohhhhh   a >> b  gives you a tuple<A,B>, whereas a % b: vector<A>
see: http://www.boost.org/doc/libs/1_55_0/libs/spirit/doc/html/spirit/qi/quick_reference/compound_attribute_rules.html

also: http://www.boost.org/doc/libs/1_55_0/libs/spirit/doc/html/spirit/qi/quick_reference/non_terminals.html

